# -*- coding: utf-8 -*-
"""
Created on Fri Nov  8 19:47:52 2024
@author: azzy
Fixed on Feb 21, 2025 by Grok 3
Updated with continuation and reversal logic based on win rate, trend age, and price change
RSI zone logic for exits, no stop loss, SuperTrend multiplier 1.5, RSI period 14
Updated on Feb 26, 2025 with number_of_positions_decider for sideways market adaptation
"""

from keys import api_key, api_secret  # Ensure keys.py has api_key and api_secret
import pandas as pd
import numpy as np
from datetime import datetime
from time import sleep
from binance.client import Client
from binance.enums import *
from binance.exceptions import BinanceAPIException
import logging

# **Logging Configuration**
ENABLE_LOGGING = True  # Set to True for INFO logs, False for WARNING and above
logging.basicConfig(
    level=logging.INFO if ENABLE_LOGGING else logging.WARNING,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# **Fixed Interval**
INTERVAL = Client.KLINE_INTERVAL_30MINUTE

# **Leverage and Margin Safety Function**
def Lsafe(client, symbol, mrgType, lvrg):
    try:
        position_info = client.futures_position_information(symbol=symbol)
        if not position_info:
            logger.error(f"No position information found for {symbol}")
            return
        position = position_info[0]
        if 'leverage' in position and 'marginType' in position:
            current_leverage = int(position['leverage'])
            current_margin_type = position['marginType']
            if current_leverage != lvrg:
                client.futures_change_leverage(symbol=symbol, leverage=lvrg)
                logger.info(f"Leverage set to {lvrg} for {symbol}")
            if current_margin_type != mrgType:
                client.futures_change_margin_type(symbol=symbol, marginType=mrgType)
                logger.info(f"Margin type set to {mrgType} for {symbol}")
        else:
            logger.error(f"Position info missing keys for {symbol}: {position}")
    except BinanceAPIException as e:
        if e.code != -4046:  # Ignore "no need to change" errors
            logger.warning(f"Failed to set leverage/margin for {symbol}: {e}")
    except Exception as e:
        logger.error(f"Unexpected error in Lsafe for {symbol}: {e}")

# **Utility Function**
def truncate(number, precision):
    factor = 10.0 ** precision
    return int(number * factor) / factor

# **ATR and SuperTrend Calculations**
def calculate_atr(df, period=14):
    high_low = df['high'] - df['low']
    high_close = abs(df['high'] - df['close'].shift())
    low_close = abs(df['low'] - df['close'].shift())
    tr = high_low.combine(high_close, max).combine(low_close, max)
    return tr.rolling(window=period).mean()

def supertrend(df, period=14, multiplier=1.5):
    atr = calculate_atr(df, period)
    hl2 = (df['high'] + df['low']) / 2
    upper_band = hl2 + (multiplier * atr)
    lower_band = hl2 - (multiplier * atr)
    supertrend = pd.Series(index=df.index, dtype=float)
    direction = pd.Series(index=df.index, dtype=int)
    supertrend.iloc[0] = lower_band.iloc[0]
    direction.iloc[0] = 1
    for i in range(1, len(df)):
        if direction.iloc[i-1] == 1:
            supertrend.iloc[i] = max(lower_band.iloc[i], supertrend.iloc[i-1]) if df['close'].iloc[i] > lower_band.iloc[i] else upper_band.iloc[i]
            direction.iloc[i] = 1 if df['close'].iloc[i] > supertrend.iloc[i] else -1
        else:
            supertrend.iloc[i] = min(upper_band.iloc[i], supertrend.iloc[i-1]) if df['close'].iloc[i] < upper_band.iloc[i] else lower_band.iloc[i]
            direction.iloc[i] = -1 if df['close'].iloc[i] < supertrend.iloc[i] else 1
    df['supertrend'] = supertrend
    df['supertrend_direction'] = direction
    return df

# **Fetch Token Data with SuperTrend**
def fetch_token_data(client, token_name, stmulti=1.5):
    try:
        candles = client.futures_klines(symbol=token_name, interval=INTERVAL)
        df = pd.DataFrame(candles, columns=['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend',
                                            'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume',
                                            'taker_buy_quote_asset_volume', 'unused_field'])
        for col in ['timestart', 'close', 'volume', 'high', 'low', 'open']:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        df['timestart'] = (df['timestart'] / 1000).astype(int)
        df = supertrend(df, period=14, multiplier=stmulti)
        df = df[['timestart', 'close', 'volume', 'high', 'low', 'open', 'supertrend', 'supertrend_direction']]
        df.sort_values(by='timestart', inplace=True)
        df.reset_index(drop=True, inplace=True)
        return df
    except Exception as e:
        logger.error(f"Failed to fetch data for {token_name}: {e}")
        return pd.DataFrame()

def get_trend_age(df):
    """Calculate the age of the current trend."""
    if df.empty or 'supertrend_direction' not in df.columns:
        return 0
    direction = df['supertrend_direction'].iloc[-1]
    age = 0
    for i in range(len(df)-1, -1, -1):
        if df['supertrend_direction'].iloc[i] == direction:
            age += 1
        else:
            break
    return age

# **MotherAI Class for Dynamic Allocation**
class MotherAI:
    def __init__(self, client, total_balance, min_allocation=5, max_allocation=10, min_bots=1, bot_limit=5):
        self.client = client
        self.total_balance = total_balance
        self.min_allocation = min_allocation
        self.max_allocation = max_allocation
        self.min_bots = min_bots
        self.bot_limit = bot_limit  # Maximum number of bots (positions) allowed

    def get_token_performance(self, token_name):
        """Fetch performance metrics for a token."""
        try:
            trades = self.client.futures_account_trades(symbol=token_name)
            if not trades:
                return 0, 50  # Default if no trades
            total_trades = len(trades)
            win_rate = sum(1 for trade in trades if float(trade['realizedPnl']) > 0) / total_trades * 100
            net_pnl = sum(float(trade['realizedPnl']) for trade in trades)
            return net_pnl, win_rate
        except Exception as e:
            logger.error(f"Error fetching trades for {token_name}: {e}")
            return 0, 50

    def decide_total_bots(self, win_rates):
        """Decide the total number of bots (positions) based on average win rate."""
        if not win_rates:
            return self.min_bots
        avg_win_rate = sum(win_rates) / len(win_rates)
        if avg_win_rate <= 40:
            total_bots = self.min_bots
        elif avg_win_rate >= 60:
            total_bots = self.bot_limit
        else:
            # Linear interpolation between min_bots and bot_limit
            total_bots = self.min_bots + int((self.bot_limit - self.min_bots) * (avg_win_rate - 40) / 20)
        return total_bots

    def decide_allocation(self, win_rate):
        """Decide allocation percentage based on win rate."""
        if win_rate <= 40:
            allocation_pct = self.min_allocation
        elif win_rate >= 60:
            allocation_pct = self.max_allocation
        else:
            allocation_pct = self.min_allocation + (self.max_allocation - self.min_allocation) * (win_rate - 40) / 20
        return (allocation_pct / 100) * self.total_balance

# **Batch Decision Function with Continuation and Reversal Logic**
def batchDecider(client, excludedlist, CurrencyType, BotLimit):
    try:
        account_info = client.futures_account()
        total_balance = float(account_info['totalWalletBalance'])
        mother_ai = MotherAI(client, total_balance, min_allocation=5, max_allocation=10, min_bots=3, bot_limit=BotLimit)
        exInfo = client.futures_exchange_info()
    except Exception as e:
        logger.error(f"Error initializing batchDecider: {e}")
        return {}

    symInfo = {symbol["symbol"]: symbol["quantityPrecision"] for symbol in exInfo["symbols"]
               if symbol["contractType"] == "PERPETUAL" and CurrencyType in symbol["symbol"] and symbol["status"] == "TRADING"}

    eligible_tokens = []
    threshold_pct = 1  # Minimum price change percentage

    for key in symInfo.keys():
        if key in excludedlist:
            continue
        try:
            df = fetch_token_data(client, key)
            if len(df) < 2:
                continue
            last_price = df.iloc[-1]["close"]
            prev_price = df.iloc[-2]["close"]
            price_change_pct = ((last_price - prev_price) / prev_price) * 100
            if abs(price_change_pct) < threshold_pct:
                continue
            trend = df['supertrend_direction'].iloc[-1]
            trend_age = get_trend_age(df)
            net_pnl, win_rate = mother_ai.get_token_performance(key)

            # Continuation or Reversal Logic
            if (price_change_pct > 0 and trend == 1) or (price_change_pct < 0 and trend == -1):
                # Continuation trade
                score = win_rate - trend_age + abs(price_change_pct)
                direction = 'FL' if trend == 1 else 'FS'
            elif (price_change_pct < 0 and trend == 1) or (price_change_pct > 0 and trend == -1):
                # Reversal trade
                score = (100 - win_rate) + trend_age + abs(price_change_pct)
                direction = 'FS' if trend == 1 else 'FL'
            else:
                continue

            eligible_tokens.append((key, direction, score, win_rate))
        except Exception as e:
            logger.error(f"Error processing {key}: {e}")

    if not eligible_tokens:
        logger.info("No eligible tokens found.")
        return {}

    # Decide total number of bots
    win_rates = [win_rate for _, _, _, win_rate in eligible_tokens]
    total_bots = mother_ai.decide_total_bots(win_rates)
    total_bots = min(total_bots, len(eligible_tokens))  # Ensure we don't exceed available tokens

    # Select top tokens based on score
    sorted_tokens = sorted(eligible_tokens, key=lambda x: x[2], reverse=True)
    top_tokens = sorted_tokens[:total_bots]

    # Decide allocation for each top token
    token_decisions = {}
    for token, direction, score, win_rate in top_tokens:
        allocation = mother_ai.decide_allocation(win_rate)
        token_decisions[token] = [score, direction, allocation]

    logger.info(f"Decided to use {total_bots} bots out of {len(eligible_tokens)} eligible tokens.")
    return token_decisions

# **Token Exchange Info**
def tokenexchangeinfodata(client, CurrencyType):
    try:
        exInfo = client.futures_exchange_info()
        return {symbol["symbol"]: symbol["quantityPrecision"] for symbol in exInfo["symbols"]
                if symbol["contractType"] == "PERPETUAL" and CurrencyType in symbol["symbol"] and symbol["status"] == "TRADING"}
    except Exception as e:
        logger.error(f"Error fetching exchange info: {e}")
        return {}

# **RSI Calculation**
def calculate_latest_rsi(df, period=14):
    if 'close' not in df.columns or len(df) < period + 1:
        return None
    delta = df['close'].diff()
    gain = delta.where(delta > 0, 0.0)
    loss = -delta.where(delta < 0, 0.0)
    avg_gain = gain.rolling(window=period, min_periods=1).mean()
    avg_loss = loss.rolling(window=period, min_periods=1).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi.iloc[-1]

# **Market Data Fetch**
def fetch_market_data(client, symbol):
    try:
        candles = client.futures_klines(symbol=symbol, interval=INTERVAL, limit=100)
        df = pd.DataFrame(candles, columns=['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend',
                                            'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume',
                                            'taker_buy_quote_asset_volume', 'unused_field'])
        df['timestart'] = df['timestart'].astype(float) / 1000
        df['timeend'] = df['timeend'].astype(float) / 1000
        for col in ['open', 'high', 'low', 'close', 'volume']:
            df[col] = df[col].astype(float)
        return df
    except BinanceAPIException as e:
        logger.error(f"API Error fetching {symbol}: {e}")
        return None

# **Order Placement**
def place_order(client, symbol, side, quantity, precision, mode):
    if mode == 'R':
        try:
            quantity = truncate(quantity, precision)
            order = client.futures_create_order(symbol=symbol, type=ORDER_TYPE_MARKET, side=side, quantity=quantity)
            logger.info(f"Order placed: {symbol}, {side}, Qty: {quantity}")
            return order
        except BinanceAPIException as e:
            logger.error(f"Order failed for {symbol}: {e}")
            return None
    else:  # Simulation mode
        quantity = truncate(quantity, precision)
        logger.info(f"Simulated order: {symbol}, {side}, Qty: {quantity}")
        return {'symbol': symbol, 'side': side, 'executedQty': str(quantity)}

# **Close Position**
def close_position(client, symbol, mode):
    if mode == 'R':
        try:
            position_info = client.futures_position_information(symbol=symbol)
            position_amt = position_info[0]['positionAmt']
            if float(position_amt) == 0:
                logger.info(f"No position to close for {symbol}")
                return None
            close_side = SIDE_SELL if float(position_amt) > 0 else SIDE_BUY
            abs_qty = position_amt.lstrip('-')
            result = client.futures_create_order(
                symbol=symbol,
                type=ORDER_TYPE_MARKET,
                side=close_side,
                quantity=abs_qty,
                reduceOnly='true'
            )
            logger.info(f"Closed {symbol}: {position_amt}, Qty: {abs_qty}")
            return result
        except BinanceAPIException as e:
            logger.error(f"Close failed for {symbol}: {e}")
            return None
    else:  # Simulation mode
        logger.info(f"Simulated close: {symbol}")
        return True

# **RSI Zone Determination**
def determine_zone(rsi):
    if rsi is None:
        return 0
    if  rsi > 70: return 4
    elif 50 <= rsi < 70: return 3
    elif 30 <= rsi < 50: return 2
    elif rsi < 31: return 1
    return 0

# **Main Trading Logic**
def newwave_Trader(CurrencyType, BotLimit, lvrg, mode):
    client = Client(api_key, api_secret)
    mrgType = "ISOLATED"
    TradeLog = {}
    LowerLimit = 2
    FFcheck = 0
    avoid_list = []

    while True:
        keys_to_remove = []
        if len(TradeLog) <= LowerLimit:
            FFcheck = 0
            try:
                TokenList = batchDecider(client, avoid_list, CurrencyType, BotLimit)
                if ENABLE_LOGGING:
                    logger.info(f'Tokens found: {TokenList}')
                tinfo = tokenexchangeinfodata(client, CurrencyType)
                for Ti, tdata in TokenList.items():
                    if Ti not in TradeLog and Ti not in ['USDCUSDT', 'BTCDOMUSDT'] and Ti not in avoid_list:
                        Lsafe(client, Ti, mrgType, lvrg)
                        df = fetch_market_data(client, Ti)
                        if df is None:
                            continue
                        opprice = df['close'].iloc[-1]
                        side = SIDE_BUY if tdata[1] == "FL" else SIDE_SELL
                        qty = tdata[2] / opprice  # allocation / price
                        p = place_order(client, Ti, side, qty, tinfo[Ti], mode)
                        if p and 'executedQty' in p:
                            initial_zone = determine_zone(calculate_latest_rsi(df))
                            TradeLog[Ti] = [tdata[1], opprice, p['executedQty'], initial_zone]
                            avoid_list.append(Ti)
                            sleep(5)
                        if len(TradeLog) >= BotLimit:
                            break
            except Exception as e:
                logger.error(f"Main loop error: {e}")
                sleep(60)

        if mode == 'R':
            account_positions = client.futures_account()
            active_positions = {pos['symbol']: pos for pos in account_positions['positions'] if float(pos['positionAmt']) != 0}
            for Ti in list(TradeLog.keys()):
                if Ti not in active_positions:
                    logger.info(f"Token {Ti} manually exited")
                    keys_to_remove.append(Ti)
        else:
            pass

        for key in keys_to_remove:
            TradeLog.pop(key, None)

        if FFcheck == 1:
            for Ti, Token_info in list(TradeLog.items()):
                direction, entry_price, amount, current_zone = Token_info
                try:
                    df = fetch_market_data(client, Ti)
                    if df is None:
                        continue
                    latest_RSI = calculate_latest_rsi(df)
                    latest_zone = determine_zone(latest_RSI)
                    if direction == 'FL':  # Long
                        if latest_zone < current_zone:
                            close_position(client, Ti, mode)
                            logger.info(f"Long closed: {Ti}, zone {latest_zone} < {current_zone}")
                            keys_to_remove.append(Ti)
                        elif latest_zone > current_zone:
                            TradeLog[Ti][3] = latest_zone
                    elif direction == 'FS':  # Short
                        if latest_zone > current_zone:
                            close_position(client, Ti, mode)
                            logger.info(f"Short closed: {Ti}, zone {latest_zone} > {current_zone}")
                            keys_to_remove.append(Ti)
                        elif latest_zone < current_zone:
                            TradeLog[Ti][3] = latest_zone
                except Exception as e:
                    logger.error(f"Trade processing error for {Ti}: {e}")

        for key in keys_to_remove:
            TradeLog.pop(key, None)

        if len(avoid_list) > BotLimit * 2:
            avoid_list = []
        
        FFcheck = 1
        sleep(1800)  # 30-minute delay

if __name__ == "__main__":
    print('Booted up...')
    newwave_Trader(CurrencyType="USDT", BotLimit=7, lvrg=2, mode='R')
